# -*- coding: utf-8 -*-
"""Copy of Document_Scanner.ipynb

Automatically generated by Colaboratory.

#**Doc-Scanner**
"""

#import Required Libraries
import numpy as np
import cv2 as cv 
from google.colab.patches import cv2_imshow 
from skimage import io
from skimage.exposure import rescale_intensity
from PIL import Image 
import matplotlib.pylab as plt

"""###Original Image"""

url = "https://image.shutterstock.com/image-illustration/blank-paper-on-wood-table-260nw-499370920.jpg"
image = io.imread(url) 
image_1 = cv.cvtColor(image, cv.COLOR_BGR2RGB)
image_1 = image_1[0:240, 0:390]
cv2_imshow(image_1)

"""### Noise Reduction"""

#Noise Reduction
denoise = cv.fastNlMeansDenoisingColored(image_1,None,5,10,7,21)
b,g,r = cv.split(denoise)           
rgb_denoise = cv.merge([r,g,b])     
cv2_imshow(denoise)

"""### Edge Detection"""

#Canny Edge Detection
edges = cv.Canny(denoise,100,200)
cv2_imshow(edges)

"""### Contour Detection"""

#Contour Detection
def thresh_callback(image, val):
  threshold = val
  canny_output = cv.Canny(image, threshold, threshold*2)
  contours, hierarchy = cv.findContours(canny_output, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
  return contours

src_gray = cv.cvtColor(denoise, cv.COLOR_BGR2GRAY)
src_gray = cv.blur(src_gray, (3,3))

contours = thresh_callback(src_gray, 100)
cntrs = np.array(contours)
contours = sorted(contours, key = cv.contourArea, reverse = True)[:5]
for c in contours:
  peri = cv.arcLength(c, True)
  approx = cv.approxPolyDP(c, 0.02 * peri, True)
  if len(approx)>=4:
    screenCnt = approx
    break
imagecopy=denoise.copy()
cv.drawContours(imagecopy, [screenCnt], -1, (0, 255, 0), 2)
cv2_imshow(imagecopy)
imagecopy2=denoise.copy()
imagecopy3=denoise.copy()

"""### Corner Detection"""

#Finding Corners
corners = cv.goodFeaturesToTrack(src_gray, 27, 0.01, 10)
corners = np.int0(corners)
  
for i in corners:
    x, y = i.ravel()
    cv.circle(imagecopy2, (x, y), 3, 255, -1)
  
cv2_imshow(imagecopy2)

"""###Perspective Transformation"""

#Perspective Transformation
pts1 = np.float32([corners[1][0], corners[2][0],corners[3][0], corners[0][0]])
width=imagecopy3.shape[1]
height=imagecopy3.shape[0]
pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])
matrix=cv.getPerspectiveTransform(pts1,pts2)
result1=cv.warpPerspective(imagecopy3,matrix,(width,height))
cv2_imshow(result1)

"""###Resize"""

#Resize
while (1):
  scale=int(input("Please enter Factor you wish to scale image by "))
  if (scale<1):
     print("Please enter valid value")
  else:
    break

#Scaling
width=int(result1.shape[1]*scale/100)
height=int(result1.shape[0]*scale/100)
dim=(width,height)
result1=cv.resize(result1,dim,interpolation=cv.INTER_AREA)
cv2_imshow(result1)

"""###Brightness"""

#Brightness
  brightness=int(input("Please enter Factor you wish to brighten image by (ex. +60,+100,-45,-80,+20 etc)  "))

image_shifted = cv.add(result1, brightness)
image_shifted = np.clip(image_shifted, 0, 255)
cv2_imshow(image_shifted)

"""###Contrast"""

src_gray = cv.cvtColor(image_shifted, cv.COLOR_BGR2GRAY)
src_gray = cv.blur(src_gray, (3,3))
image_cv_eq = cv.equalizeHist(src_gray)
cv2_imshow(image_cv_eq)

"""###Rotation"""

#Rotation
rotate=int(input("-Rotate clockwise by 90 degree enter 1\n-Rotate anticlockwise by 90 degree enter 2\n-Rotate by 180 degree enter 3\n "))

if rotate==1:
  image = cv.rotate(image_shifted, cv.ROTATE_90_CLOCKWISE)
elif rotate==2:
  image=cv.rotate(image_shifted,cv.ROTATE_90_ANTICLOCKWISE)
elif rotate==3:
  image=cv.rotate(image_shifted,cv.ROTATE_180)
cv2_imshow(image)
